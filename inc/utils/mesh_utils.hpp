#ifndef OLYMPUS__UTILS__MESH_UTILS
#define OLYMPUS__UTILS__MESH_UTILS

#include <glm/glm.hpp>

#include "render/mesh.hpp"

namespace olympus {
    /**
     * The goal of this file is to create some functions that
     * can be used tho accelerate objects that need to create meshes.
     * This includes simple things like making a flat plane, calucating normals,
     * etc.
     */

    //NOTE: To make templates work we include the actual code in here. Be careful about where you include
    //      this header since it will need to recompile every translation unit.

    /// Creates a plane of a constant value
    template<typename T> T *create_plane(unsigned width, unsigned height, const T value) {
        T *result = new T[width * height];
        T *ptr = result;
        for (unsigned i = 0; i < height; i++) {
            for (unsigned j = 0; j < width; j++) {
                *ptr++ = value;
            }
        }
        return result;
    }

    /**
     * Creates a plane of type T, with the given width and height. The value at each point
     * is computed with the compute function. This must have the following prototype:
     *
     * T compute(unsigned max_width, unsigned max_height, unsigned current_x, unsigned current_y, void *);
     *
     * Extra data can be passed in using the last parameter.
     */
    template<typename T> T *create_plane(unsigned width, unsigned height,
                                         T (*compute) (unsigned, unsigned, unsigned, unsigned, void *),
                                         void *extra_data
                                        ) {

        T *result = new T[width * height];
        T *ptr = result;
        for (unsigned i = 0; i < height; i++) {
            for (unsigned j = 0; j < width; j++) {
                *ptr++ = compute(width, height, j, i, extra_data);
            }
        }
        return result;
    }

    /**
     * Returns an array of indicies that can be used to create a TRIANGLES mesh out of a mesh generated by
     * create plane.
     */
    unsigned *generate_plane_indices(unsigned width, unsigned height);

    /**
     * Takes in an indexed listh of vertices and caluclates face normals. Only supports TRIANGLE type meshes.
     */
    glm::vec3 *generate_normals(glm::vec3 *verts, unsigned *indicies, unsigned num_indices, unsigned num_verts);

    /**
     * The following hepler functions can be fed into create_plane to create standard types of planes
     */

    /**
     * This will simply output a vec3 of xz position. The final parameter can store a float which will
     * be used for scaling.
     */
    glm::vec3 position_helper(unsigned width, unsigned height, unsigned x, unsigned y, void *scale);
    glm::vec2 position_helper_2D(unsigned width, unsigned height, unsigned x, unsigned y, void *scale);

    /**
     * Simple function to make a square out of a height map.
     */
    glm::vec3 heightmap_sub(unsigned width, unsigned height, unsigned x, unsigned y, void *height_map);

    /* Begin functions for common meshes */

    /**
     * Creates a UV sphere with the given values.
     */
    Mesh *create_uv_sphere(float radius, unsigned rows, unsigned cols);

    /**
     * Creates a simple mesh for an icosphere.
     */
    Mesh *create_icosphere(float radius, unsigned recursion);
};
#endif
